DEFAULT_GOAL := all
.PHONY : all build clean distclean prep prep_bucket deploy s3copy meta

# One of the gret strengths of using Make for this is that it can avoid re-building code
# when it is not needed. This Makefile takes pains to enumerate the build products and
# avoids building and uploading a new archive if there have been no changes.

# Thanks Stack Overflow http://stackoverflow.com/a/8080530/424301
DIR := $(dir $(lastword $(MAKEFILE_LIST)))
SHELL := /bin/bash

SRC := $(DIR)src
BUILD := $(DIR)build
UPSTREAM_BUILD := $(DIR)../../../succeed
UPSTREAM_PACKAGE := $(UPSTREAM_BUILD)/build/package
ARCHIVE_DIR := $(DIR)build/archive
PHP_BUILD_VERSION_FILE=$(ARCHIVE_DIR)/etc/phpversion.txt
BUILD_TIMESTAMP_FILE := $(ARCHIVE_DIR)/etc/timestamp.txt
# Generated by Jenkinsfile.
TAG_FILE := $(UPSTREAM_BUILD)/TAG
# Credits: https://lists.gnu.org/archive/html/help-make/2009-05/msg00009.html
BUILD_META_DIR := $(abspath $(dir $(ARCHIVE_DIR)/etc))
BUILD_META_FILE := $(BUILD_META_DIR)/meta.txt
PHP_BUILD_VERSION_DIR=$(ARCHIVE_DIR)/etc
APP_NAME := succeed
APP_PATH := var/www/applications/succeed
ARCHIVE := $(APP_NAME)
ZIP := $(BUILD)/$(ARCHIVE).zip
BUILD_DEPLOY_FOLDER_NAME := build-deploy
BUILD_DEPLOY := $(UPSTREAM_BUILD)/$(BUILD_DEPLOY_FOLDER_NAME)
GRADLE_TARGETS := clean init npmInstall test prepareBundle copyBundle gruntLegacyUiMin
SKIP_RUN := false
MONITOR_DEPLOYMENT := $(DIR)../../bin/monitor-deployment.sh
GET_BUILD_NUMBER := $(DIR)../../bin/get_build_number.sh
get_s3_file=$(2)-$(shell  $(GET_BUILD_NUMBER) $(1)).zip
AWS_ACCOUNT_ID := $(shell \
	. $(DIR)/../../bin/common.sh >/dev/null 2>&1  && \
	get_aws_account_id)

# Thanks Stack Overflow https://stackoverflow.com/questions/38801796/makefile-set-if-variable-is-empty
ifeq ($(AWS_ACCOUNT_ID),)
     $(error AWS_ACCOUNT_ID not defined)
endif

BUCKET_NAME := unmanaged-codedeploy-$(AWS_ACCOUNT_ID)
BUCKET := s3://$(BUCKET_NAME)

# This determines what version of PHP to deploy.
# Possible values are '5.6' '56' '53' '5.3'. This gets parsed.
# TODO: 5.3 - feature/aws-migration
# TODO: 5.6 - feature/php-56-upgrade (feature/NAWS-320-prod-frontend-succeed56 for now)
PHP_VERSION := 56

# Do not override this directly
PHP_VERSION_CODE := $(shell $(DIR)../../bin/get-php-version.sh $(PHP_VERSION))
ifeq ($(PHP_VERSION_CODE),56)
	DOCKERFILE_NAME := Dockerfile.ci
else
	DOCKERFILE_NAME := Dockerfile
endif

CONTAINER_TAG_NAME := $(APP_NAME)-codedeploy-$(PHP_VERSION_CODE):$(shell $(GET_BUILD_NUMBER) $(DIR)Makefile)

DEPLOYMENT_APP := tf-succeed-$(PHP_VERSION_CODE)
DEPLOYMENT_GROUP := qa

# Setting IASF=true sets the CodeDeply deployment flag "--ignore-application-stop-failure"
# in order to work around a failed application stop lifecycle event.
IASF := false
ifeq ($(IASF),true)
        IASF_FLAG := --ignore-application-stop-failure
else
        IASF_FLAG :=
endif

# Thanks Stack Overflow http://stackoverflow.com/a/18258352/424301
# This expression has a limitation that it won't work on directories that have spaces
rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) $(filter $(subst *,%,$2),$d))

SOURCES := $(call rwildcard, $(SRC), *) \
    $(call rwildcard, $(BUILD_DEPLOY), *)

# docker build is fast to run the second time around.
# don't sweat the dependencies.
build:
	$(DIR)/../../bin/vpn-check.sh
	cd $(UPSTREAM_BUILD) \
	&& docker build -f=$(BUILD_DEPLOY_FOLDER_NAME)/$(DOCKERFILE_NAME) . -t $(CONTAINER_TAG_NAME) \
	&& echo "Docker built OK with $(DOCKERFILE_NAME)"

# Generate meta data to a file so that create-deployments.sh can pick it up
# and send it to NewRelic.
meta:
	$(DIR)/../../bin/vpn-check.sh
	mkdir -p $(BUILD_META_DIR)
	TAG_VAL=$$(cat $(TAG_FILE)) && \
	echo "$(shell $(GET_BUILD_NUMBER)) $(UPSTREAM_BRANCH) $$TAG_VAL" > $(BUILD_META_FILE)

$(ZIP): $(SOURCES)
	$(DIR)/../../bin/vpn-check.sh
	mkdir -p $(PHP_BUILD_VERSION_DIR)
	echo "$$(date +%Y%m%d%H%M)" > $(BUILD_TIMESTAMP_FILE)

	docker run --rm -v $$(pwd):/$(APP_PATH) $(CONTAINER_TAG_NAME) /bin/bash -c \
		"/bin/bash --login -c '\
			php --version \
				| head -n1 \
				| cut -d\" \" -f2 \
				| cut -d\".\" -f1,2 \
				| cut -d\".\" -f1,2'" \
				> $(PHP_BUILD_VERSION_FILE)
	# Check for the PHP version here and fail early.
	PHP_BUILD_VERSION=$$(cat $(PHP_BUILD_VERSION_FILE)); \
	PHP_VERSION_PARSED=$$($(DIR)../../bin/get-php-version.sh $$PHP_BUILD_VERSION); \
	if [ $$PHP_VERSION_PARSED != "${PHP_VERSION_CODE}" ]; then \
		echo "ERROR: The project was built with PHP version $$PHP_VERSION_PARSED but the expected version is ${PHP_VERSION_CODE}"; \
		exit 1; \
	fi
	# Thanks Stack Overflow https://stackoverflow.com/a/31482558/424301
	cd $(UPSTREAM_BUILD) &&	\
	if [ $(SKIP_RUN) = false ]; then \
		docker run --rm -v $$(pwd):/$(APP_PATH) $(CONTAINER_TAG_NAME) /bin/bash -c \
		"/bin/bash --login -c '\
			cd /$(APP_PATH) && \
			export GRADLE_USER_HOME="~/.gradle" && \
			./gradlew $(GRADLE_TARGETS)'"; \
	fi
	# TODO: This is dependent on the work originated in the branch "feature/aws-migration"
	#       in succeed. We need to get that merged into develop pronto! cc: @mmcaya
	rsync -a $(SRC)/ $(UPSTREAM_PACKAGE) $(UPSTREAM_BUILD)/build-deploy/codedeploy $(ARCHIVE_DIR)
	rsync -a \
		$(DIR)../../bin/aws/ \
		$(DIR)../../bin/manage-splunk.sh \
		$(ARCHIVE_DIR)/bin
	for f in $(ARCHIVE_DIR)/appspec.yml $(ARCHIVE_DIR)/bin/common.sh $(ARCHIVE_DIR)/etc/*.json; do \
		sed -i.bak -e "s/{{ APP_NAME }}/${APP_NAME}/g" $$f \
		&& rm -f $$f.bak; \
	done
	for f in $(ARCHIVE_DIR)/bin/common.sh; do \
		sed -i.bak -e "s/{{ PHP_VERSION }}/${PHP_VERSION_CODE}/g" $$f \
		&& rm -f $$f.bak; \
	done
	. $(DIR)../../bin/common.sh \
		&& ensure_zip
	cd $(ARCHIVE_DIR) \
		&& zip -q -r ../../$(ZIP) *
	# We are going to fake out Make by touching this file when we are
	# done with the build, so that we can avoid re-running the docker
	# stuff and the zip file if we can avoid it.
	touch $(BUILD_DEPLOY)/$(DOCKERFILE_NAME)

clean:
	rm -rf $(BUILD)

distclean: clean
	rm -rf $(UPSTREAM_BUILD)/build

prep:
	mkdir -p $(ARCHIVE_DIR)

prep_bucket:
	. $(DIR)/../../env.sh && \
	    . $(DIR)../../bin/common.sh \
			&& ensure_awscli
	. $(DIR)/../../env.sh && \
		aws s3 ls $(BUCKET) >/dev/null \
			|| aws s3 mb $(BUCKET)

s3_copy = S3_FILE=$(call get_s3_file,$(1),$(2)) && \
 	S3_PHP_BUILD_VERSION_FILE=$(BUCKET)/$(APP_NAME)/$${S3_FILE}.php-version.txt && \
 	S3_BUILD_META_FILE=$(BUCKET)/$(APP_NAME)/$${S3_FILE}.meta.txt && \
 	aws s3 ls $(BUCKET)/$(APP_NAME)/$$S3_FILE \
 	&& echo "File in S3 is already up to date" \
 	|| (aws s3 cp $(1) $(BUCKET)/$(APP_NAME)/$$S3_FILE && \
 		aws s3 cp $(PHP_BUILD_VERSION_FILE) $$S3_PHP_BUILD_VERSION_FILE && \
 		aws s3 cp $(BUILD_META_FILE) $$S3_BUILD_META_FILE)

# This uses a trick from https://stackoverflow.com/a/11474509/424301 to scroll the screen up
deploy: prep $(ZIP) s3copy
	. $(DIR)/../../env.sh && \
	S3_FILE=$(call get_s3_file,$(ZIP),$(ARCHIVE)) && \
	deployment=$$(aws deploy create-deployment \
        $(IASF_FLAG) \
		--application-name $(DEPLOYMENT_APP) \
		--s3-location bucket=$(BUCKET_NAME),key=$(APP_NAME)/$$S3_FILE,bundleType=zip \
		--deployment-group-name $(DEPLOYMENT_GROUP) \
		--output text)  && \
	$(MONITOR_DEPLOYMENT) $$deployment

s3copy: $(ZIP) prep_bucket
	. $(DIR)/../../env.sh && \
		$(call s3_copy,$(ZIP),$(ARCHIVE))

all: prep build $(ZIP) prep_bucket s3copy
