.DEFAULT_GOAL := all
.PHONY : all build clean distclean prep prep_bucket deploy s3copy meta

# One of the gret strengths of using Make for this is that it can avoid re-building code
# when it is not needed. This Makefile takes pains to enumerate the build products and
# avoids building and uploading a new archive if there have been no changes.

# Thanks Stack Overflow http://stackoverflow.com/a/8080530/424301
DIR := $(dir $(lastword $(MAKEFILE_LIST)))
SHELL := /bin/bash

SRC := $(DIR)src
BUILD := $(DIR)build
UPSTREAM_BUILD := $(DIR)../../../succeed-legacy
UPSTREAM_PACKAGE := $(UPSTREAM_BUILD)/build/package
UPSTREAM_BUILD_LAUSD := $(DIR)../../../naviance-lausd-etl
ARCHIVE_DIR := $(DIR)build/archive
PHP_BUILD_VERSION_FILE := $(ARCHIVE_DIR)/etc/phpversion.txt
PHP_BUILD_VERSION_DIR := $(ARCHIVE_DIR)/etc
# Generated by Jenkinsfile.
TAG_FILE := $(UPSTREAM_BUILD)/TAG
# Credits: https://lists.gnu.org/archive/html/help-make/2009-05/msg00009.html
BUILD_META_DIR := $(abspath $(dir $(ARCHIVE_DIR)/etc))
BUILD_META_FILE := $(BUILD_META_DIR)/meta.txt
APP_NAME := cron-legacy
APP_PATH := /var/www/application/succeed-legacy
APP_PATH_LAUSD := /opt/naviance/lausd-etl
ARCHIVE := $(APP_NAME)
ZIP := $(BUILD)/$(ARCHIVE).zip
BUILD_DEPLOY_FOLDER_NAME := build-deploy
BUILD_DEPLOY := $(UPSTREAM_BUILD)/$(BUILD_DEPLOY_FOLDER_NAME)
GRADLE_TARGETS := clean init test prepareBundle copyBundle
SKIP_RUN := false
SKIP_RUN_LAUSD := false
MONITOR_DEPLOYMENT := $(DIR)../../bin/monitor-deployment.sh
GET_BUILD_NUMBER := $(DIR)../../bin/get_build_number.sh
get_s3_file=$(2)-$(shell  $(GET_BUILD_NUMBER) $(1)).zip
AWS_ACCOUNT_ID := $(shell \
	. $(DIR)/../../bin/common.sh >/dev/null 2>&1  && \
	get_aws_account_id)

# Thanks Stack Overflow https://stackoverflow.com/questions/38801796/makefile-set-if-variable-is-empty
ifeq ($(AWS_ACCOUNT_ID),)
     $(error AWS_ACCOUNT_ID not defined)
endif

BUCKET_NAME := unmanaged-codedeploy-$(AWS_ACCOUNT_ID)
BUCKET := s3://$(BUCKET_NAME)

# This determines what version of PHP to deploy.
# Possible values are '5.6' '56' '53' '5.3'. This gets parsed.
# TODO: 5.3 - feature/aws-migration
# TODO: 5.6 - feature/php-56-upgrade (feature/NAWS-320-prod-frontend-succeed56 for now)
PHP_VERSION := 56

# Do not override this directly
PHP_VERSION_CODE := $(shell $(DIR)../../bin/get-php-version.sh $(PHP_VERSION))
DOCKERFILE_NAME := Dockerfile.ci


CONTAINER_TAG_NAME := $(APP_NAME)-codedeploy-$(PHP_VERSION_CODE):$(shell $(GET_BUILD_NUMBER) $(DIR)Makefile)

ifeq ($(PHP_VERSION_CODE),53)
    CONTAINER_TAG_LAUSD := centos:6.9
else
    CONTAINER_TAG_LAUSD := centos:7.4.1708
endif

DEPLOYMENT_APP := tf-cron-legacy
DEPLOYMENT_GROUP := qa

# Thanks Stack Overflow http://stackoverflow.com/a/18258352/424301
# This expression has a limitation that it won't work on directories that have spaces
rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) $(filter $(subst *,%,$2),$d))

SOURCES := $(call rwildcard, $(SRC), *) \
    $(call rwildcard, $(BUILD_DEPLOY), *)


# docker build is fast to run the second time around.
# don't sweat the dependencies.
build:
	$(DIR)/../../bin/vpn-check.sh
	cd $(UPSTREAM_BUILD) \
	&& \
	if [ "$(PHP_VERSION_CODE)" == "53" ]; then \
		docker build -f=$(BUILD_DEPLOY_FOLDER_NAME)/$(DOCKERFILE_NAME) $(BUILD_DEPLOY_FOLDER_NAME) -t $(CONTAINER_TAG_NAME) ; \
	else \
		docker build -f=$(BUILD_DEPLOY_FOLDER_NAME)/$(DOCKERFILE_NAME) . -t $(CONTAINER_TAG_NAME) ; \
	fi \
	&& echo "Docker built OK with $(DOCKERFILE_NAME)"

# Generate meta data to a file so that create-deployments.sh can pick it up
# and send it to NewRelic.
meta:
	$(DIR)/../../bin/vpn-check.sh
	mkdir -p $(BUILD_META_DIR)
	TAG_VAL=$$(cat $(TAG_FILE)) && \
	echo "$(shell $(GET_BUILD_NUMBER)) $(UPSTREAM_BRANCH) $$TAG_VAL" > $(BUILD_META_FILE)

$(ZIP): $(SOURCES)
	$(DIR)/../../bin/vpn-check.sh
	# Thanks succeed Makefile :p
	mkdir -p $(PHP_BUILD_VERSION_DIR)
	docker run --rm -v $$(pwd):$(APP_PATH) $(CONTAINER_TAG_NAME) /bin/bash -c \
		"/bin/bash --login -c '\
			php --version \
				| head -n1 \
				| cut -d\" \" -f2 \
				| cut -d\".\" -f1,2 \
				| cut -d\".\" -f1,2'" \
				> $(PHP_BUILD_VERSION_FILE)
	# Check for the PHP version here and fail early.
	PHP_BUILD_VERSION=$$(cat $(PHP_BUILD_VERSION_FILE)); \
	PHP_VERSION_PARSED=$$($(DIR)../../bin/get-php-version.sh $$PHP_BUILD_VERSION); \
	if [ $$PHP_VERSION_PARSED != "${PHP_VERSION_CODE}" ]; then \
		echo "ERROR: The project was built with PHP version $$PHP_VERSION_PARSED but the expected version is ${PHP_VERSION_CODE}"; \
		exit 1; \
	fi
	cd $(UPSTREAM_BUILD) &&	\
	if [ $(SKIP_RUN) = false ]; then \
		docker run --rm -v $$(pwd):$(APP_PATH) $(CONTAINER_TAG_NAME) /bin/sh -c \
		'cd $(APP_PATH) && ./gradlew $(GRADLE_TARGETS)'; \
	fi
	mkdir -p $(ARCHIVE_DIR)/cron
	rsync -a $(SRC)/ $(UPSTREAM_PACKAGE) $(UPSTREAM_BUILD)/build-deploy/cron/succeed-legacy-cron-all $(ARCHIVE_DIR)
	rsync -a \
		$(DIR)../../bin/aws/ \
		$(DIR)../../bin/manage-splunk.sh \
		$(ARCHIVE_DIR)/bin
	mv $(ARCHIVE_DIR)/succeed-legacy-cron-all $(ARCHIVE_DIR)/cron/crontab
	for f in $(ARCHIVE_DIR)/appspec.yml $(ARCHIVE_DIR)/bin/common.sh; do \
		sed -i.bak -e "s/{{ APP_NAME }}/${APP_NAME}/g" $$f \
		&& rm -f $$f.bak; \
	done
	for f in $(ARCHIVE_DIR)/bin/common.sh; do \
		sed -i.bak -e "s/{{ PHP_VERSION }}/${PHP_VERSION_CODE}/g" $$f \
		&& rm -f $$f.bak; \
	done
	. $(DIR)../../bin/common.sh \
		&& ensure_zip
	#
	# Now we are dealing with LAUSD etl
	cd $(UPSTREAM_BUILD_LAUSD) &&	\
	if [ $(SKIP_RUN_LAUSD) = false ]; then \
		if [ "$(PHP_VERSION_CODE)" == "53" ]; then \
			docker run --rm -v $$(pwd):/$(APP_PATH_LAUSD) $(CONTAINER_TAG_LAUSD) /bin/sh -c \
			'cd $(APP_PATH_LAUSD)                                                            && \
			yum groupinstall -y "Development Tools"                                          && \
			yum install -y centos-release-SCL scl-utils-build                                && \
			yum install -y python27 python27-python-pip python27-build libffi                   \
							python27-python-devel openssl-devel libffi-devel mysql-devel     && \
			scl enable python27 "pip install virtualenv"                                     && \
			scl enable python27 "virtualenv -p /opt/rh/python27/root/usr/bin/python2.7 venv" && \
			scl enable python27 "source venv/bin/activate ; pip install -r requirements.txt"    \
			' ; \
		else \
			docker run --rm -v $$(pwd):/$(APP_PATH_LAUSD) $(CONTAINER_TAG_LAUSD) /bin/sh -c \
			'cd $(APP_PATH_LAUSD)                         && \
			yum groupinstall -y "Development Tools"       && \
			yum install -y epel-release                   && \
			yum install -y python python2-pip python-devel mysql-devel && \
			pip install virtualenv                        && \
			virtualenv -p /usr/bin/python2.7 venv         && \
			( source venv/bin/activate ; pip install -r requirements.txt ) \
			' ; \
		fi \
	fi
	mkdir -p $(ARCHIVE_DIR)/lausd-etl
	cp -fa $(UPSTREAM_BUILD_LAUSD)/* $(ARCHIVE_DIR)/lausd-etl
	#
	# Now zipping it all
	cd $(ARCHIVE_DIR) \
		&& zip -q -r ../../$(ZIP) *
	# We are going to fake out Make by touching this file when we are
	# done with the build, so that we can avoid re-running the docker
	# stuff and the zip file if we can avoid it.
	touch $(BUILD_DEPLOY)/$(DOCKERFILE_NAME)

clean:
	rm -rf $(BUILD)

distclean: clean
	rm -rf $(UPSTREAM_BUILD)/build


prep:
	mkdir -p $(ARCHIVE_DIR)

prep_bucket:
	. $(DIR)/../../env.sh && \
	    . $(DIR)../../bin/common.sh \
			&& ensure_awscli
	. $(DIR)/../../env.sh && \
		aws s3 ls $(BUCKET) >/dev/null \
			|| aws s3 mb $(BUCKET)

# This uses a trick from https://stackoverflow.com/a/11474509/424301 to scroll the screen up
deploy: prep $(ZIP) s3copy
	. $(DIR)/../../env.sh && \
	S3_FILE=$(call get_s3_file,$(ZIP),$(ARCHIVE)) && \
	deployment=$$(aws deploy create-deployment \
		--application-name $(DEPLOYMENT_APP) \
		--s3-location bucket=$(BUCKET_NAME),key=$(APP_NAME)/$$S3_FILE,bundleType=zip \
		--deployment-group-name $(DEPLOYMENT_GROUP) \
		--output text)  && \
	$(MONITOR_DEPLOYMENT) $$deployment

s3_copy = S3_FILE=$(call get_s3_file,$(1),$(2)) && \
 	S3_PHP_BUILD_VERSION_FILE=$(BUCKET)/$(APP_NAME)/$${S3_FILE}.php-version.txt && \
 	S3_BUILD_META_FILE=$(BUCKET)/$(APP_NAME)/$${S3_FILE}.meta.txt && \
 	aws s3 ls $(BUCKET)/$(APP_NAME)/$$S3_FILE \
 	&& echo "File in S3 is already up to date" \
 	|| (aws s3 cp $(1) $(BUCKET)/$(APP_NAME)/$$S3_FILE && \
 		aws s3 cp $(PHP_BUILD_VERSION_FILE) $$S3_PHP_BUILD_VERSION_FILE && \
 		aws s3 cp $(BUILD_META_FILE) $$S3_BUILD_META_FILE)

# If the Jenkins BUILD_NUMBER env var exists, we use that to build
# an S3_FILE filename variable, else we use the timestamp of the
# archive file in YYYYMMDDTHHMMSS format to build the filename.
# Thanks Stack Overflow http://stackoverflow.com/a/36964153/424301
s3copy: $(ZIP) prep_bucket
	. $(DIR)/../../env.sh && \
		$(call s3_copy,$(ZIP),$(ARCHIVE))

all: prep build $(ZIP) prep_bucket s3copy
